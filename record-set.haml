!!! 5

%link(rel="import" href="../polymer/polymer.html")
%link(rel="import" href="../core-ajax/core-ajax.html")

%polymer-element(name="record-set" attributes="href")
  %template
  :coffeescript
    __data = {}
    __dummy = {data: 0}
    __href = undefined
    __fields = {}
    
    getFields = (record) -> 
      return __fields[record.tagName] if __fields[record.tagName]?

      p = HTMLElement.getPrototypeForTag record.tagName
      loop
        throw "not a record: " + record.tagName unless p.element.extends?
        break if p.element.extends == "record-base"
        p = HTMLElement.getPrototypeForTag p.element.extends
      __fields[record.tagName] = (k for own k,v of p.publish) # rid is excluded
    
    Polymer
      href: undefined
      _data: undefined
      _dummy: undefined
      computed:
        all: '_extractRecords(_data, _dummy.data)' # TODO dummy was added so changes within _data are observed
      created: () ->
        @_data = __data
        @_dummy = __dummy
      ready: () ->
        __href = @href if @href?
        @href = __href if @href != __href
      save: (record, remote, prevRid) ->
        data = record
        if remote?
          remote.rid = remote.id
          delete remote.id
          data = remote
        @_data[record.type] = { records: {}, next: 1 } unless @_data[record.type]?
        r = @_data[record.type].records[prevRid || data.rid]
        r = {} unless r?
        if prevRid? and r.rid = prevRid
          delete @_data[record.type].records[prevRid]
          r.rid = data.rid
        unless r.rid?
          r.rid = if remote? then remote.rid else ("rs:" + @_data[record.type].next++)
        @_data[record.type].records[r.rid] = r
        record.rid = r.rid # write potential new rid back to element
        for k in getFields record
          r[k] = data[k]
        @_dummy.data++
      load: (record) ->
        if @_data[record.type]? and @_data[record.type].records[record.rid]?
          for k,v of @_data[record.type].records[record.rid]
            record[k] = v unless k == "rid"
      delete: (record) ->
        if @_data[record.type]? and @_data[record.type].records[record.rid]?
          delete @_data[record.type].records[record.rid]
          @_dummy.data++
      getRawRecord: (record) -> @_data[record.type].records[record.rid] if @_data[record.type]? and @_data[record.type].records[record.rid]?
      _extractRecords: (data) ->
        new ->
          @[type] = (record.rid for id,record of value.records) for type,value of data
          @

%polymer-element(name="record-base" attributes="rid persist type noautoload")
  %template
    %record-set(id="set")
    %core-ajax(id="pull" handleAs="json" url="{{_resUrl}}" method="GET" on-core-response="{{_handlePull}}")
    %core-xhr(id="xhr")
  :coffeescript
    Polymer
      rid: undefined
      persist: undefined
      type: "record"
      noautoload: undefined
      observe: {
        '$.set.all': '_doAutoLoad' # TODO: overkill ! use fine grained events
      }
      computed:
        #type: '_lc(tagName)' # todo auto detection of type name
        all: '$.set.all[type]'
        _resUrl: "$.set.href + '/' + type"
        _resIdUrl: "$.set.href + '/' + type + '/' + rid"
      ready: () ->
        @save() if @persist?
        @load() if @rid? and not @noautoload?
      save: () ->
        @$.set.save @ 
      load: () ->
        @$.set.load @
      delete: () ->
        @$.set.delete @
      pull: () ->
        @$.pull.go()
      _handlePull: (e, d) ->
        if Array.isArray d.response
          for record in d.response
            @$.set.save @, record 
        else
          for k, record of d.response
            record.id = k unless record.id?
            @$.set.save @, record
      saveRemote: () ->
        @save()
        rid = @rid
        @$.xhr.request
          url: @_resIdUrl
          method: 'PUT'
          body: JSON.stringify (@$.set.getRawRecord @)
          responseType: 'json'
          headers: {'Content-Type': 'application/json'}
          callback: (r) =>
            true # TODO: mark as synced?
      createRemote: () ->
        @save()
        rid = @rid
        @$.xhr.request
          url: @_resUrl
          method: 'POST'
          body: JSON.stringify (@$.set.getRawRecord @)
          responseType: 'json'
          headers: {'Content-Type': 'application/json'}
          callback: (r) =>
            @$.set.save @, r, rid
      deleteRemote: () ->
        rid = @rid
        @$.xhr.request
          url: @_resIdUrl
          method: 'DELETE'
          responseType: 'json'
          headers: {'Content-Type': 'application/json'}
          callback: (r) =>
            true # TODO: restore record locally on error
        @delete()
      _doAutoLoad: () ->
        @load() unless @noautoload?
      _lc: (s) -> s.toLowerCase()
      noautoloadChanged: () -> @_doAutoLoad()

